# Rust book 学习笔记

- **《The Rust Programming Language》或中文版《Rust权威指南》**

## 说明

- **每个知识点对应一个binary crate,即src下的一个文件，用cargo workspace管理**
- **用cargo run --bin 文件夹名称（ 即binary crate name）的方式运行**
- **lib项目auto_test，用cargo test -p auto_test测试后**

## 1、依赖 

- ​	**添加crate 依赖：**
  - **在Cargo.toml文件[dependencies]下可按照如下的格式添加依赖**
  - **rand = "0.7.0"**
  - **上面的格式其实是rand = "^0.7.0"的简写，表示依赖在0.7.0以上，但小于0.8.0的版本，cargo build 第一次运行时会创建Cargo.lock文件，并将依赖版本写入，只有在Cargo.toml更新了0.8.0以上的版本时，Cargo.lock文件才会更新**



## 2、变量和数据类型

### 	4种标量类型

- 整数类型：

  - | Length  | Signed  | Unsigned |
    | ------- | ------- | -------- |
    | 8-bit   | `i8`    | `u8`     |
    | 16-bit  | `i16`   | `u16`    |
    | 32-bit  | `i32`   | `u32`    |
    | 64-bit  | `i64`   | `u64`    |
    | 128-bit | `i128`  | `u128`   |
    | arch    | `isize` | `usize`  |

  - 整数的表达方法，除了Byte外，其他整数类型可以使用类型作后缀：如：98**u32**

  - | Number literals  | Example       |
    | ---------------- | ------------- |
    | Decimal          | `98_222`      |
    | Hex              | `0xff`        |
    | Octal            | `0o77`        |
    | Binary           | `0b1111_0000` |
    | Byte (`u8` only) | `b'A'`        |

- 浮点类型

  - | Length | Signed |
    | ------ | ------ |
    | 32     | `f32`  |
    | 64     | `f64`  |

- 布尔类型

  - true
  - false

- 字符类型

  - char作为类型签名，使用单引号，占**4个字节**大小

### 2种复合类型

- tuple
  - （）
  - 保存多个类型的多个值
  - 长度固定，一旦声明不能更改
  - 支持使用模式匹配进行解构
- 数组
  - []
  - 保存同一类型的多个值
  - 其他同tuple

### 函数

- 函数或者代码块{}的最后一个表达式（不带分号，即；）即为函数或者代码块的返回值，语句（带分号）的返回值为空tuple，即（）
- 也可以使用return返回，返回值必须在函数声明中指明类型
- let 关键字只能在函数内部声明变量

## 3、变量所有权Ownership

### 所有权规则

- 每个值都有一个变量，这个变量是该值的所有者
- 每个值同时只能有一个所有者
- 当所有者超出作用域时，该值被删除（自动调用drop函数）

### 深拷贝和浅拷贝

浅拷贝：只复制stack上的数据引用，不复制heap上的数据本身：![截屏2022-10-31 09.57.40](pics/008vxvgGly1h7ogtm216lj30hk0h80tl-20221101162228836.jpg)

深拷贝：复制stack上的数据引用和heap上的数据：![截屏2022-10-31 09.58.19](pics/008vxvgGly1h7ogu4qvaij30hr0kb0tv.jpg)

### rust的所有权转移（move）

复制stack上的引用，将之前的引用销毁（图中s1变灰色），不复制heap上的数据本身：



![截屏2022-10-31 09.58.02.png](pics/n_v21681327f398d431eb5ab147003fb04de-20221101162214849.png)



### rust的copy和drop trait

- 实现了copy trait的数据存在stack上，通过只拷贝存储在栈上的位来复制值
- 如果一个类型或者类型的一部分实现了drop trait ,就不允许再实现copy trait
- 拥有copy trait的类型：
  - 4种标量类型（整数类型、浮点类型、布尔类型、字符类型）
  - tuple ，如果其中所有元素都是实现了copy trait的话

### 所有权和函数

- 函数的调用和返回值也伴随着所有权的转移
- 借用：把变量的引用作为函数的参数的行为
- 使用的变量的引用作为形参使API更具通用型，并不会带来性能上的损失

### 引用的解释和规则

- &：引用的表示符号，允许使用变量的值而不取得变量的所有权
- 引用的本质（s作为s1的引用）：![截屏2022-10-31 12.59.46](pics/008vxvgGly1h7oguc3oi7j30ul0awmxv.jpg)
- 在同一个作用域内，只能满足下列条件中的一个，不能同时满足
  - 一个可变的引用
  - 任意数不可变的引用
- 切片：对变量中部分内容的引用，形式：&[开始索引..结束索引]
- 切片的语法糖：
  - &[..从开始到索引]
  - &[从索引到结束..]
  - &[..] 表示整个数据的切片



## 4、结构体struct

- struct规则
  - 为每个字段指定具体值
  - 字段是无序的
  - 实例化时必须为所有字段赋值
  - 通过`点(dot)`标记法获取具体字段的值和赋值
  - 使用 `let` 默认示例化的 struct 是不可变（immutable），可以通过 `let mut` 声明可变（mutable）的 struct
  - 可变的 struct 实例，所有字段都是可变的
  - struct 可以作为函数的返回值，如 `-> City`
  - 简写规则：若字段名和字段值对应变量名相同时，可以使用字段名初始化
- struct更新
  - 基于某个 struct 实例创建一个新的 struct 实例时，可以在新的实例中使用 `..实例名` 来替代不需要修改的字段，需要修改的字段需要单独指定
- struct数据所有权
  - 若实例拥有 struct 里所有字段的所有权，则 struct 拥有所有权
  - 若存在引用（如`&str`）类型的字段，则需要使用`生命周期（lifetime specifier）？`
    - 若生命周期保证struct实例是有效的，则里面的引用也是有效的
    - 若struct里面存储引用，且不使用生命周期，则会报错
- struct方法
  - 在 `impl` 块里定义方法，一个 struct 可以有多个 `impl` 块
  - struct 方法的第一个参数是 `&self`，也可以获得其所有权和可变借用
  - 结构体实例使用 `.` 方法调用方法
- struct关联函数:在 `impl` 块里定义的函数，第一个参数不是 `self
  - 作用：通常用于构造器
  - 调用：结构体名称::函数名()
    - :: 符号的作用
      - 关联函数
      - 模块创建的命名空间
  - 示例：String::from()

## 5、枚举和模式匹配

- 枚举的访问：枚举类型名::值1;`，如：`let name = CityKind::sh;
  - 枚举的变体都位于标识符的命名空间下，使用 `::` 进行访问
- 数据附加到枚举的变体中
  - 定义
    enum 枚举类型名 {
      值1(类型、结构体或枚举等),
      值2(类型或结构体),
    }
  - 优点
    - 不需要额外使用 struct 就能存储值
    - 每个变体可以拥有不同的类型和关联的数据量

## 6、代码组织Package, Crate, Module

- 层级结构：![截屏2022-11-01 15.31.22.png](pics/n_v25c68890e1ae04673a422b7ee48337f68.png)
- 组织规则：![截屏2022-11-01 15.43.21.png](pics/n_v209feb408034d47d09ec7c9e073acb2af.png)

## 7、Common Collections常见集合

- String类型的含义

- ![截屏2022-11-03 13.33.17](pics/%E6%88%AA%E5%B1%8F2022-11-03%2013.33.17.png)

- HashMap数据所有权

  ![截屏2022-11-03 14.39.02](pics/%E6%88%AA%E5%B1%8F2022-11-03%2014.39.02.png)

## 8、Error Handling错误处理

- ![截屏2022-11-03 18.42.40](pics/%E6%88%AA%E5%B1%8F2022-11-03%2018.42.40.png)
- ![截屏2022-11-03 18.42.49](pics/%E6%88%AA%E5%B1%8F2022-11-03%2018.42.49.png)
- ![截屏2022-11-03 18.42.57](pics/%E6%88%AA%E5%B1%8F2022-11-03%2018.42.57.png)

## 9、泛型、trait、生命周期

![截屏2022-11-04 14.50.36](pics/%E6%88%AA%E5%B1%8F2022-11-04%2014.50.36.png)

![截屏2022-11-07 14.12.29](pics/%E6%88%AA%E5%B1%8F2022-11-07%2014.12.29.png)

## 10、测试

![截屏2022-11-07 22.25.24](pics/%E6%88%AA%E5%B1%8F2022-11-07%2022.25.24.png)

![截屏2022-11-07 22.26.09](pics/%E6%88%AA%E5%B1%8F2022-11-07%2022.26.09.png)

![截屏2022-11-07 22.29.19](pics/%E6%88%AA%E5%B1%8F2022-11-07%2022.29.19.png)

![截屏2022-11-07 22.30.39](pics/%E6%88%AA%E5%B1%8F2022-11-07%2022.30.39.png)

![截屏2022-11-07 22.35.06](pics/%E6%88%AA%E5%B1%8F2022-11-07%2022.35.06.png)

![截屏2022-11-07 22.36.40](pics/%E6%88%AA%E5%B1%8F2022-11-07%2022.36.40.png)

## 11、IO example 一个简单程序例子

![截屏2022-11-08 09.10.55](pics/%E6%88%AA%E5%B1%8F2022-11-08%2009.10.55.png)

![截屏2022-11-08 09.32.41](pics/%E6%88%AA%E5%B1%8F2022-11-08%2009.32.41.png)

## 12、迭代器格闭包 Iterators and Closures

![截屏2022-11-08 16.08.34](pics/%E6%88%AA%E5%B1%8F2022-11-08%2016.08.34.png)

![截屏2022-11-08 17.41.59](pics/%E6%88%AA%E5%B1%8F2022-11-08%2017.41.59.png)

![截屏2022-11-09 11.45.25](pics/%E6%88%AA%E5%B1%8F2022-11-09%2011.45.25.png)

## 12、智能指针 Smart Pointers

![截屏2022-11-15 12.10.02](pics/%E6%88%AA%E5%B1%8F2022-11-15%2012.10.02.png)

![截屏2022-11-15 12.17.06](pics/%E6%88%AA%E5%B1%8F2022-11-15%2012.17.06.png)

![截屏2022-11-15 13.51.52](pics/%E6%88%AA%E5%B1%8F2022-11-15%2013.51.52.png)

![截屏2022-11-15 14.28.29](pics/%E6%88%AA%E5%B1%8F2022-11-15%2014.28.29.png)

## 13、无畏并发 Fearless Concurrency

![截屏2022-11-16 11.39.50](pics/%E6%88%AA%E5%B1%8F2022-11-16%2011.39.50.png)

![截屏2022-11-16 17.15.55](pics/%E6%88%AA%E5%B1%8F2022-11-16%2017.15.55.png)

![截屏2022-11-16 17.16.32](pics/%E6%88%AA%E5%B1%8F2022-11-16%2017.16.32.png)

## 14、模式匹配：Patterns and Matching
