# Rust book 学习笔记

- **《The Rust Programming Language》或中文版《Rust权威指南》**

## 说明

- **每个知识点对应一个binary crate,即src下的一个文件，用cargo workspace管理**
- **运行：用cargo run --bin 文件夹名称（ 即binary crate name）的方式运行**
- **测试：例如lib项目auto_test，测命令 cargo test -p auto_test**

## 1、依赖 

- ​	**添加crate 依赖：**
  - **在Cargo.toml文件[dependencies]下可按照如下的格式添加依赖**
  - **rand = "0.7.0"**
  - **rust 采用的是语义化版本控制，具体见[SemVer](https://semver.org)**



## 2、变量和数据类型

### 	4种标量类型

- 整数类型：整数的表达方法，除了Byte外，其他整数类型可以使用类型作后缀：如：98**u32**
- 浮点类型

- 布尔类型

- 字符类型


### 2种复合类型

- tuple
  - （）
  - 保存多个类型的多个值
  - 长度固定，一旦声明不能更改
  - 支持使用模式匹配进行解构
- 数组
  - []
  - 保存同一类型的多个值
  - 其他同tuple

### 函数

- 函数或者代码块{}的最后一个表达式（不带分号，即；）即为函数或者代码块的返回值，语句（带分号）的返回值为空tuple，即（）
- 也可以使用return返回，返回值必须在函数声明中指明类型
- let 关键字只能在函数内部声明变量



## 3、变量所有权Ownership

### 所有权规则

- 每个值都有一个变量，这个变量是该值的所有者
- 每个值同时只能有一个所有者
- 当所有者超出作用域时，该值被删除（自动调用drop函数）



### 深拷贝和浅拷贝

浅拷贝：只复制stack上的数据引用，不复制heap上的数据本身

深拷贝：复制stack上的数据引用和heap上的数据。



### rust的所有权转移（move）

复制stack上的引用，将之前的引用销毁，不复制heap上的数据本身：



### rust的copy和drop trait

- 实现了copy trait的数据存在stack上，通过只拷贝存储在栈上的位来复制值
- 如果一个类型或者类型的一部分实现了drop trait ,就不允许再实现copy trait
- 拥有copy trait的类型：
  - 4种标量类型（整数类型、浮点类型、布尔类型、字符类型）
  - tuple ，如果其中所有元素都是实现了copy trait的话
  
  

### 所有权和函数

- 函数的调用和返回值也伴随着所有权的转移
- 借用：把变量的引用作为函数的参数的行为
- 使用的变量的引用作为形参使API更具通用型，并不会带来性能上的损失



### 引用的解释和规则

- &：引用的表示符号，允许使用变量的值而不取得变量的所有权
- 引用的本质：reference
- 在同一个作用域内，只能满足下列条件中的一个，不能同时满足
  - 一个可变的引用
  - 任意数不可变的引用
- 切片：对变量中部分内容的引用，形式：&[开始索引..结束索引]
- 切片的语法糖：
  - &[..从开始到索引]
  - &[从索引到结束..]
  - &[..] 表示整个数据的切片



## 4、结构体struct

- struct规则
  - 为每个字段指定具体值
  - 字段是无序的
  - 实例化时必须为所有字段赋值
  - 通过`点(dot)`标记法获取具体字段的值和赋值
  - 使用 `let` 默认示例化的 struct 是不可变（immutable），可以通过 `let mut` 声明可变（mutable）的 struct
  - 可变的 struct 实例，所有字段都是可变的
  - struct 可以作为函数的返回值，如 `-> City`
  - 简写规则：若字段名和字段值对应变量名相同时，可以使用字段名初始化
- struct更新
  - 基于某个 struct 实例创建一个新的 struct 实例时，可以在新的实例中使用 `..实例名` 来替代不需要修改的字段，需要修改的字段需要单独指定
- struct数据所有权
  - 若实例拥有 struct 里所有字段的所有权，则 struct 拥有所有权
  - 若存在引用（如`&str`）类型的字段，则需要使用`生命周期（lifetime specifier）？`
    - 若生命周期保证struct实例是有效的，则里面的引用也是有效的
    - 若struct里面存储引用，且不使用生命周期，则会报错
- struct方法
  - 在 `impl` 块里定义方法，一个 struct 可以有多个 `impl` 块
  - struct 方法的第一个参数是 `&self`，也可以获得其所有权和可变借用
  - 结构体实例使用 `.` 方法调用方法
- struct关联函数:在 `impl` 块里定义的函数，第一个参数不是 `self
  - 作用：通常用于构造器
  - 调用：结构体名称::函数名()
    - :: 符号的作用
      - 关联函数
      - 模块创建的命名空间
  - 示例：String::from()
  
  

## 5、枚举和模式匹配

- 枚举的访问：枚举类型名::值1;`，如：`let name = CityKind::sh;
  - 枚举的变体都位于标识符的命名空间下，使用 `::` 进行访问
- 数据附加到枚举的变体中
  - 定义
    enum 枚举类型名 {
      值1(类型、结构体或枚举等),
      值2(类型或结构体),
    }
  - 优点
    - 不需要额外使用 struct 就能存储值
    - 每个变体可以拥有不同的类型和关联的数据量
    
    

## 6、代码组织Package, Crate, Module

- 层级结构：

  - Package(包)：cargo的特性，让你构建、测试、共享crate
  - Crate(单元包)：一个模块术，它可以产生一个library或可执行文件
  - Module(模块)：让你控制代码的组织、作用域、私有路径
  - Path(路径)：为struct、function或module等命名的方式

  

- 组织规则：

  - Crate的类型：
    - binary
    - library

  - Crate Root:
    - 是源代码文件
    - Rust编译器从这里开始，组成你的Crate的根Module

  - 一个Package:
    - 包含一个Cargo.toml，它描述了如何构建这些Crates
    - 只能包含0-1个Library Crate
    - 但是可以包含任意数量的binary crate
    - 但至少包含一个crate（library或者binary）


  

## 7、Common Collections常见集合

- String类型的含义，Rust 有三种看待字符串的方式：

  - Bytes：字节

  - Scalar Values：标量值

  - Grapheme Clusters：字形簇（最接近所谓“字母”）


  

- HashMap数据所有权

  - 对于实现了Copy trait的类型（例如i32），值会被复制到HashMap中
  - 对于拥有所有权的值（例如String），值会被移动，所有权会转移给HashMap
  - 如果将值的引用插入到HashMap，值本身不会移动，在HashMap有效的期间，被引用的值必须保持有效。

  

## 8、Error Handling错误处理

- Result 枚举

  - ```rust
    pub enum Result<T, E> {
        Ok(T),
        Err(E),
    }
    ```

  - T：操作成功的情况下，OK变体里返回的数据类型

  - E：操作失败的情况下，Err变体里返回的数据类型

- Rust 错误处理概述

  - Rust的可靠性：大部分情况下，在编译时提示错误，并处理
  - Rust 没有类似异常的机制
    - 可恢复错误：Result<T,E>
    - 不可恢复：panic! 宏

- 场景建议

  - 调佣你的代码，传入无意义的参数值：panic！
  - 调用外部不可控代码，返回非法状态，你无法修复：panic！
  - 如果是失败是可预期的：Result
  - 当你的代码对值进行操作，首先验证这些值：panic！




## 9、泛型、trait、生命周期

- 方法定义中的泛型

  - 为struc或enum实现方法的时候，可在定义中使用泛型

  - 把T放在impl关键字后，表示在类型T上实现方法，例如：

    - ```rust
      impl<T> Point<T>
      ```

  - 只针对具体类型实现的方法（其余类型没有实现方法），例如：

    - ```rust
      impl Point<f32>
      ```

  - struct 里的泛型类型参数可以和方法的泛型类型参数不同。

- 生命周期省略的三个规则

  - 规则1：每个引用类型的参数都有自己的生命周期
  - 规则2：如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数
  - 规则3：如果有多个输入生命周期参数，但其中一个是&self 或 &mut self ，那么self的生命周期会被赋给所有的输出生命周期参数
  - 编译器使用3个规则在没有显示标注生命周期的情况下，来确定引用的生命周期：
    - 规则1应用与输入生命周期
    - 规则2、3应用于输出生命周期
    - 如果编译器应用完三个规则之后，仍然存在无法确定生命周期的引用，则会报错
    - 这些规则使用于fn定义和impl块



## 10、测试

- 控制测试如何运行
  - 改变cargo test 的行为：添加命令行参数
  - 默认行为：
    - 并行运行
    - 所有测试
    - 捕获（不显示）所有输出，是读取与测试结果相关的输出更容易
  - 命令行参数：
    - 针对cargo test的参数：紧跟cargo test 后
    - 针对测试可执行程序，放在 -- 之后
  - cargo test --help
  - cargo test -- --help
- 并行运行测试
  - 运行多个测试：默认使用多个线程并行运行，运行快。
  - 确保多个测试之间：
    - 不会互相依赖
    - 不依赖于某个共享状态（环境、工作目录、环境变量等等）
- --test-threads 参数
  - 传递给二进制文件
  - 不想以并行的方式运行测试，或想对线程数进行细粒度的控制
  - 可以使用--test-threads参数，后面紧跟线程的数量，如：
    - cargo test -- --test-threads=1
- 显示函数输出
  - 默认，如果测试通过，Rust 的test库会捕获所有打印到标准输出的内容
  - 例如代码中使用了println！
    - 如果测试通过：不会看到打印的内容
    - 如果测试失败：会看到打印内容和失败信息
  - 如果一定要看到打印的内容，添加参数：--show-output
- 忽略某些测试
  - 添加ignore参数
  - 单独运行被忽略的测试：cargo test -- --ignored
- #[cfg(test)]标注
  - tests模块上的#[cfg(test)]标注：
    - 只有运行cargo test 才编译和运行代码
    - 运行cargo build 则不会
  - 集成测试在不容的目录，它不需要#[cfg(test)]标注
  - cfg：configuration（配置）
    - 告诉Rust下面的条目只有在指定的配置选项下才被包含
    - 配置选项test：由Rust 提供，用来编译和运行测试。
    - 只有cargo test 才会编译代码，包括模块中的helper函数和#[test]标注的函数



## 11、IO example 一个简单程序例子

- ​	二进制程序关注点分离的指导性原则
  - 将程序拆分为main.rs和lib.rs，将业务逻辑放入lib.rs
  - 当命令行解析逻辑较少时，将它放在main.rs也行
  - 当命令行解析逻辑变复杂时，需要将它从main.rs提取到lib.rs
- 经过上述拆分，留在main函数的功能有：
  - 使用参数值调用命令行解析逻辑
  - 进行其他设置
  - 调用lib.rs中的run函数
  - 处理run函数可能出现的错误



## 12、迭代器格闭包 Iterators and Closures

- Fn Trait
  - Fn Trait由标准库提供
  - 所有的闭包都至少实现了一下trait之一：
    - Fn
    - FnMut
    - FnOnce
- 闭包从所在环境中捕获值的方式
  - 与函数获得参数的三种方式一样：
    - 取得所有权：FnOnce
    - 可变借用：FnMut
    - 不可变借用：Fn
  - 创建闭包时，通过闭包对环境值的使用，Rust推断出具体使用哪个Trait：
    - 所有的闭包都实现了FnOnce
    - 没有移动的捕获变量实现了FnMut
    - 无需可访问捕获变量的闭包实现了Fn
- 几个迭代方法：
  - iter方法：在不可变引用上常见迭代器
  - into_iter方法：创建的迭代器会获得所有权
  - iter_mut方法：迭代可变的引用





## 12、智能指针 Smart Pointers

- Rc::clone() VS 类型的clone()方法

  - Rc::clone()：增加引用，不会执行数据的深度拷贝操作
  - 类型的clone()：很多会执行数据的深度拷贝操作

- 选择Box< T >、Rc< T >、RefCell< T >的依据

  - |                  | Box < T >                      | Rc< T >                  | RefCell< T >                   |
    | ---------------- | ------------------------------ | ------------------------ | ------------------------------ |
    | 同一数据的所有者 | 一个                           | 多个                     | 一个                           |
    | 可变性、借用检查 | 可变、不可变借用（编译时检查） | 不可变借用（编译时检查） | 可变、不可变借用（运行时检查） |

    RefCell< T >本身不可变，但仍能修改其中存储的值

- 使用RefCell< T >在运行时记录借用信息

  - RefCell< T >会记录当前存在多少个活跃的Ref< T >和RefMut< T >智能指针：
    - 每次调用borrow：不可变借用计数加1
    - 任何一个Ref< T >的值离开作用域被释放时：不可变借用计数减1
    - 每次调用borrow_mut：可变借用计数加1
    - 任何一个RefMut< T >的值离开作用域被释放时：可变借用计数减1
  - 以此技术来维护借用检查规则：
    - 任何一个给定的时间里。只允许拥有多个不可变借用或者一个可变借用

- 防止循环引用把Rc< T >换成Weak< T >

  - Rc::clone 为 Rc< T > 实例的 strong count加 1，Rc< T > 的实例只有在strong_count 为 0 的时候才会被清理
  - Rc< T >实例通过调用 Rc::downgrade 方法可以创建值的 Weak Reference(弱引用)
    - 返回类型是 Weak< T >(智能指针)
    - 调用 Rc::downgrade 会为 weak count 加 1

  - Rc< T >使用 weak count 来追踪存在多少 Weak< T >

  - weak_count 不为 0 并不影响 Rc< T > 实例的清理



## 13、无畏并发 Fearless Concurrency

- RefCell< T>/Rc< T> vs Mutex< T>/Arc< T>
  - Mutex< T> 提供了内部可变性，和 Cell 家族一样
  - 我们使用 RefCell< T> 来改变 RC< T> 里面的内容
  - 我们使用 Mutex< T> 来改变 Arc< T> 里面的内容
  - 注意:Mutex< T> 有死锁风险

- Send:允许线程间转移所有权

  - 实现 Send trait 的类型可在线程间转移所有权

  - Rust 中几乎所有的类型都实现了 Send，但 Rc< T> 没有实现 Send，它只用于单线程情景
  - 任何完全由 Send 类型组成的类型也被标记为 Send
  - 除了原始指针之外，几乎所有的基础类型都是 Send

- Sync:允许从多线程访问
  - 实现 Sync 的类型可以安全的被多个线程引用
  - 也就是说:如果T是 Sync，那么 &T就是 Send，引用可以被安全的送往另一个线程
- 基础类型都是 Sync
- 完全由 Sync 类型组成的类型也是 Sync
  - 但，Rc< T>不是 Sync 的
  - RefCell< T> 和 Cell< T> 家族也不是 Sync 的
  - 而，Mutex< T>是 Sync 的



## 14、高级特性

- Unsafe 超能力

  - 使用 unsafe 关键字来切换到 unsafe Rust，开启一个块，里面放着 unsafe 代码

  - Unsafe Rust 里可执行的四个动作(unsafe 超能力):
    - 解引用原始指针
    - 调用 unsafe 函数或方法
    - 访问或修改可变的静态变量
    - 实现 unsafe trait

  - 注意:
    - unsafe 并没有关闭借用检查或停用其它安全检查
    - 任何内存安全相关的错误必须留在 unsafe 块里
    - 尽可能隔离 unsafe 代码，最好将其封装在安全的抽象里，提供安全的API

- 解引用原始指针
  - 原始指针
    - 可变的：* mut T
    - 不可变的：* const T。意味着指针在解引用后不能直接对其进行赋值
    - 注意：这里的 * 不是解引用符号，它是类型名的一部分。
  - 与引用不同，原始指针:
    - 允许通过同时具有不可变和可变指针或多个指向同一位置的可变指针来忽略借用规则一
    - 无法保证能指向合理的内存
    - 允许为 null
    -  不实现任何自动清理
  - 放弃保证的安全，换取更好的性能/与其它语言或硬件接口的能力

- 关联类型与泛型的区别

  - | 泛型                                             | 关联类型                         |
    | ------------------------------------------------ | -------------------------------- |
    | 每次实现 Trdit 时标注类型                        | 无需标注类型                     |
    | 可以为一个类型多次实现某个 Trait(不同的泛型参数) | 无法为单个类型多次实现某个 Trait |
